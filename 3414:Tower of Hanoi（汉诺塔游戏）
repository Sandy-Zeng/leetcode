题意：
汉诺塔游戏，有大小不同的盘片按从大到小的顺序叠放在一根柱子上，一共有三根柱子，问需要多少次移动才能将盘片移动到另一根柱子上，并且盘片的叠放次序不变。
在移动过程中需要遵循以下规则：
1、每次只能移动一个盘片
2、不能将大盘片叠放在小盘片的上面

对基础的汉诺塔游戏，我们知道最少的移动次数为(2^n-1),假设对前n-1个盘片移动需要的最少移动次数为F（n-1），则对第n个盘片，先将第n个盘片放到第三根柱子上，
然后再用F（n-1）次移动将剩余n-1个盘片移动到第n个盘片之上，那么所需要的全部移动次数为F（n） = 2*F（n-1）+1，F（1） = 1。
可以用递归的方式求解。

现在对游戏规则做一些调整，现在假设每钟大小的盘片不止一个，对于大小相同的两个盘片，在移动过程中可以互相叠放，但是移动过程结束之后，相同大小的盘片之间的
叠放次序要与原来的叠放次序相同。

模拟该转移过程，每次移动相同大小的所有盘片，盘片大小为1，2....n，每钟盘片的数量为a1,a2...an，则对于盘片大小为i的盘片，将ai个盘片全部从a柱子移动
到b柱子上，然后将已经移动的大小小于i的盘片叠放在这个大小的盘片上，用F（i-1）+ai次移动，这时这ai个盘片的叠放次序是逆序，但是在下一次的移动中，盘片的顺序
会被翻转。所以移动大小为1...i的所有盘片需要的最少移动次数为F（i）= 2F（i-1）+ai。
如果i==n,即最后一种大小的盘片的移动，此时的状态为，an个盘片放在a柱子上，（a1+..+an-1）个盘片放在b柱子上，c柱子为空，那么由于没有下一次的移动可以将
盘片的叠放次序翻转，所以当an>1时，需要另一种移动策略，将an-1个盘片先逆序叠放在c柱子上，用F（n-1）次移动将已经叠放好次序的盘片移动到c柱子上，将最后一个
盘片移动到b柱子上，再用F（n-1）次移动将上层盘片移动到a柱子上，将c柱子上剩余an-1个盘片移动到b柱子上，再将上层盘片从a柱子移动到b柱子上，那么最后一次移动
所需要的移动次数为 1 +3*F（n-1）+2*（an-1）

#include<iostream>
#include<queue>
#include<stdio.h>
#include<string.h>

using namespace std;

int disk[100];

int main()
{
    int n,mv;
    while(scanf("%d%d",&n,&mv)!=EOF)
    {
        memset(disk,0,sizeof(disk));
        for(int i=0;i<n;i++)
        {
            cin>>disk[i];
        }
        int times = 0;
        int record = 0;
        int orderLessNum = 0;
        for(int i=0;i<n;i++)
        {
            if(i==n-1&&disk[i]>1)
            {
                times += (1+(disk[n-1]-1)*2+3*record)%mv;   //最后一次移动
                times = times%mv;
            }
            else
            {
                times += (disk[i] + record)%mv;  //最后一次移动前的所有移动
                times = times%mv;
                record = times;
            }
        }
        cout<<times%mv<<endl;
    }
}
